# Full-Stack MCM Alerts with Supabase & Netlify

This is a full-stack, real-time monitoring PWA built with React, Vite, Supabase, and Tailwind CSS. It is configured for a seamless one-click deployment to Netlify.

This version is fully integrated with a Supabase backend for:
- **Persistent Data Storage:** Notifications, topics, and audit logs are stored in a Postgres database.
- **Real-time Updates:** The dashboard uses Supabase's real-time capabilities to instantly reflect new data.
- **Backend API:** A Supabase Edge Function provides an API endpoint to ingest new alerts.
- **Push Notifications:** The Edge Function sends real push notifications to subscribed users via Web Push.

The login mechanism remains a static `admin`/`password` check on the frontend as per the requirements.

---

## Required Setup (Crucial Steps)

You **must** follow these steps to get your own version of this application running.

### Step 1: Set up Supabase Project

1.  Go to [supabase.com](https://supabase.com) and create a new project.
2.  Go to **Project Settings > API**.
3.  Note down your **Project URL**, `anon` **public key**, and `service_role` **key**. The application code is already configured with your public keys, but you will need the service role key for the function secrets.

### Step 2: Set up Database Schema

1.  Navigate to the **SQL Editor** in your Supabase project.
2.  Click **New query**.
3.  Copy the entire SQL script below, paste it into the editor, and click **Run**. This will create all the necessary tables, types, and security policies.

```sql
-- -----------------------------------------------------------------------------
-- 1. DROP EXISTING OBJECTS (for a clean setup, optional but recommended)
-- -----------------------------------------------------------------------------
-- Uncomment and run these lines if you need to start over from a clean slate.
-- Be careful, this will delete all data in these tables.
/*
DROP TABLE IF EXISTS public.audit_logs;
DROP TABLE IF EXISTS public.topics;
DROP TABLE IF EXISTS public.push_subscriptions;
DROP TABLE IF EXISTS public.notifications CASCADE;
DROP TYPE IF EXISTS public.notification_priority;
DROP TYPE IF EXISTS public.notification_type;
DROP TYPE IF EXISTS public.audit_log_action;
*/


-- -----------------------------------------------------------------------------
-- 2. CUSTOM TYPES (ENUMS)
-- Using custom types (enums) ensures data consistency for specific fields.
-- -----------------------------------------------------------------------------

CREATE TYPE public.notification_priority AS ENUM ('low', 'medium', 'high');
CREATE TYPE public.notification_type AS ENUM ('site_down', 'server_alert', 'custom');
CREATE TYPE public.audit_log_action AS ENUM ('created', 'acknowledged', 'resolved', 'commented', 'snoozed');


-- -----------------------------------------------------------------------------
-- 3. NOTIFICATIONS TABLE
-- This is the core table that stores all incoming alert data.
-- -----------------------------------------------------------------------------

CREATE TABLE public.notifications (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  type public.notification_type NOT NULL,
  title TEXT NOT NULL,
  message TEXT NOT NULL,
  site TEXT,
  priority public.notification_priority DEFAULT 'low' NOT NULL,
  "timestamp" TIMESTAMPTZ NOT NULL,
  acknowledged BOOLEAN DEFAULT FALSE NOT NULL,
  resolved BOOLEAN DEFAULT FALSE NOT NULL,
  snoozed_until TIMESTAMPTZ,
  comments JSONB[] DEFAULT '{}'::JSONB[] NOT NULL
);

COMMENT ON TABLE public.notifications IS 'Stores all incoming alerts and their status.';
COMMENT ON COLUMN public.notifications.snoozed_until IS 'Timestamp until which the notification is hidden from the main view.';


-- -----------------------------------------------------------------------------
-- 4. AUDIT LOGS TABLE
-- Tracks all actions performed on notifications for accountability.
-- -----------------------------------------------------------------------------

CREATE TABLE public.audit_logs (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  notification_id BIGINT REFERENCES public.notifications(id) ON DELETE CASCADE,
  notification_title TEXT,
  action public.audit_log_action NOT NULL,
  "user" TEXT NOT NULL,
  details TEXT,
  "timestamp" TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

COMMENT ON TABLE public.audit_logs IS 'Tracks all actions taken on notifications.';


-- -----------------------------------------------------------------------------
-- 5. PUSH SUBSCRIPTIONS TABLE
-- Stores browser push subscription objects for sending notifications.
-- This version is corrected to avoid the SQL syntax error.
-- -----------------------------------------------------------------------------

CREATE TABLE public.push_subscriptions (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  subscription_object JSONB NOT NULL,
  endpoint TEXT UNIQUE NOT NULL -- The endpoint is the truly unique part of the subscription.
);

COMMENT ON TABLE public.push_subscriptions IS 'Stores user push notification subscription data.';
COMMENT ON COLUMN public.push_subscriptions.endpoint IS 'Unique endpoint URL for the push subscription to prevent duplicates.';


-- -----------------------------------------------------------------------------
-- 6. TOPICS TABLE
-- Stores user-created notification topics and their unique API endpoints.
-- -----------------------------------------------------------------------------

CREATE TABLE public.topics (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    subscribed BOOLEAN DEFAULT TRUE NOT NULL,
    endpoint TEXT NOT NULL
);

COMMENT ON TABLE public.topics IS 'Stores user-created notification topics.';


-- -----------------------------------------------------------------------------
-- 7. ROW LEVEL SECURITY (RLS)
-- Since auth is static, we allow broad access using the public `anon` key.
-- In a real multi-tenant app, you would lock this down with `auth.uid()`.
-- -----------------------------------------------------------------------------

ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.push_subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.topics ENABLE ROW LEVEL SECURITY;

-- Allow public read and write access for anon key
CREATE POLICY "Public access for notifications" ON public.notifications FOR ALL USING (true) WITH CHECK (true);
CREATE POLICY "Public access for audit logs" ON public.audit_logs FOR ALL USING (true) WITH CHECK (true);
CREATE POLICY "Public access for push subscriptions" ON public.push_subscriptions FOR ALL USING (true) WITH CHECK (true);
CREATE POLICY "Public access for topics" ON public.topics FOR ALL USING (true) WITH CHECK (true);


-- -----------------------------------------------------------------------------
-- 8. ENABLE REALTIME
-- This tells Supabase to broadcast changes on these tables to subscribed clients.
-- -----------------------------------------------------------------------------
-- First, drop the default publication if it exists to start fresh
DROP PUBLICATION IF EXISTS supabase_realtime;

-- Create the publication for the tables we want to be real-time
CREATE PUBLICATION supabase_realtime FOR TABLE public.notifications, public.audit_logs, public.topics;

### Step 3: Set up Push Notifications & Edge Function

1.  **Deploy the Edge Function Secrets:**
    *   Install the Supabase CLI if you haven't already: `npm install supabase --save-dev`
    *   Link your project: `npx supabase link --project-ref <YOUR_PROJECT_REF>` (e.g., `xmspqtqooufngsjnljek`)
    *   Set the required secrets. **Replace the private key with your own.** The public key is already in `src/config.ts`.
      ```bash
      npx supabase secrets set VAPID_PUBLIC_KEY=BP7_fiqB7nNL3pxcvgXDqzoFrzL4ab37XSZUV0H2sMwKC5mvvFFz7NjTXixl8e_5zoQqFZwbc3a60D0GAnxeGqA
      npx supabase secrets set VAPID_PRIVATE_KEY=XT3m6FsZuRJxN_DP-ZvIJdx1mDy4qQprqC8Z2sme-C8
      npx supabase secrets set VAPID_MAILTO=mailto:youremail@example.com
      ```
    *   Deploy the `api-ingest` function. The `--no-verify-jwt` flag is necessary because we are calling it from our frontend with the public anon key.
      ```bash
      npx supabase functions deploy api-ingest --no-verify-jwt
      ```

### Step 4: Deploy Frontend to Netlify

1.  Fork this repository to your own GitHub account.
2.  Go to [app.netlify.com](https://app.netlify.com) and create a new site from your forked repository.
3.  **Netlify will automatically detect the build settings** from `netlify.toml`. Just click "Deploy site".

### Step 5: Final Configuration (After Deployment)

1.  Once your site is live on Netlify, you will have a URL (e.g., `https://my-awesome-alerts.netlify.app`).
2.  Open `src/App.tsx` in your code.
3.  Find the `createTopic` function.
4.  Replace the placeholder `<YOUR-SITE-NAME>.netlify.app` with your actual Netlify site name.
5.  Do the same for the URL in `src/pages/ApiDocs.tsx`.
6.  Commit and push this change to your repository. Netlify will automatically redeploy the site with the correct endpoint URL.

---
## Local Development

1.  Clone your forked repository.
2.  Install dependencies: `npm install`.
3.  The `src/config.ts` file is already configured with your public keys.
4.  Run the development server: `npm run dev`.
5.  Open your browser to `http://localhost:5173`.
    *Note: The test alert button will not work locally unless you configure a proxy for your dev server. It is designed to work with the Netlify proxy on deployment.*